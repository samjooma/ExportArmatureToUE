import bpy
import os

class ActionSelectionProperty(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty()
    include_in_export: bpy.props.BoolProperty(default=False)

#
# Operators.
#

class ExportToUEOperator(bpy.types.Operator):
    bl_idname = "export_to_ue.export"
    bl_label = "Export to Unreal Engine"
    bl_description = "Exports selected armature objects and their meshes, and actions in scene, to FBX files that can be used in Unreal Engine"
    bl_options = {"REGISTER"}

    action_selections: bpy.props.CollectionProperty(type=ActionSelectionProperty)
    active_index: bpy.props.IntProperty()
    export_armature_and_meshes: bpy.props.BoolProperty(default=False, name="Export armature and meshes")

    @classmethod
    def poll(cls, context):
        valid_armatures = [
            x for x in context.selected_objects if
            x.type == "ARMATURE" and any(child.type == "MESH" for child in x.children)
        ]
        return len(valid_armatures) > 0

    def execute(self, context):
        if not context.mode == "OBJECT":
            bpy.ops.object.mode_set(mode="OBJECT")

        old_selected_objects = [x for x in context.selected_objects]
        old_active_object = context.active_object

        valid_armatures = [
            x for x in context.selected_objects if
            x.type == "ARMATURE" and any(child.type == "MESH" for child in x.children)
        ]

        #
        # Convert rigify armatures.
        #

        conversion_name_suffix = "_Converted"

        # rig_id is a custom property generated by rigify, use it to detect rigify rigs.
        rigify_armatures = [x for x in valid_armatures if x.data.get("rig_id")]

        if len(rigify_armatures) > 0:
            bpy.ops.object.select_all(action="DESELECT")
            for armature in rigify_armatures:
                armature.select_set(True)
                context.view_layer.objects.active = armature
            bpy.ops.rigify_duplication.duplicate(name_suffix=conversion_name_suffix)

        conversion_dict = {}
        for armature in valid_armatures:
            try:
                conversion_dict[bpy.data.objects[f"{armature.name}{conversion_name_suffix}"]] = armature
            except KeyError:
                pass

        valid_armatures = (set(valid_armatures) - set(conversion_dict.values())) | set(conversion_dict.keys())

        #
        # Export actions.
        #

        for valid_armature in valid_armatures:
            bpy.ops.object.select_all(action="DESELECT")
            valid_armature.select_set(True)
            context.view_layer.objects.active = valid_armature
            
            try:
                name_prefix = conversion_dict[valid_armature].name
            except KeyError:
                name_prefix = valid_armature.name

            action_selections = [{"name": x.name, "include_in_export": x.include_in_export} for x in self.action_selections]
            if len(action_selections) > 1:
                bpy.ops.quick_action_exporter.export(action_selections=action_selections, active_index=0, name_prefix=name_prefix)

        #
        # Export armature and meshes.
        #

        def remove_recursive(o):
            for child in o.children:
                remove_recursive(child)
            
            data = o.data
            bpy.data.objects.remove(o)
            try:
                bpy.data.meshes.remove(data)
            except TypeError:
                bpy.data.armatures.remove(data)

        if self.export_armature_and_meshes:
            for armature in valid_armatures:
                def is_valid_mesh(object):
                    return object.type == "MESH" and any(isinstance(x, bpy.types.ArmatureModifier) and x.object == armature for x in object.modifiers)
                child_armature_meshes = [x for x in armature.children if is_valid_mesh(x)]
                if len(child_armature_meshes) < 1:
                    continue

                # Create a duplicate and name it "Armature".

                duplicate_armature_data = armature.data.copy()
                duplicate_armature = armature.copy()
                duplicate_armature.data = duplicate_armature_data
                duplicate_armature.parent = None
                context.scene.collection.objects.link(duplicate_armature)

                context_override = context.copy()
                context_override["selected_objects"] = [duplicate_armature]
                with context.temp_override(**context_override):
                    bpy.ops.object.make_local(type="SELECT_OBDATA_MATERIAL")

                if "Armature" in bpy.data.objects:
                    self.report({"ERROR"}, "An object named \"Armature\" already exists.")
                    return {"Canceled"}
                if "Armature" in bpy.data.armatures:
                    self.report({"ERROR"}, "Armature data named \"Armature\" already exists.")
                    return {"Canceled"}

                duplicate_armature.name = "Armature"
                duplicate_armature.data.name = "Armature"

                for child_mesh in child_armature_meshes:
                    duplicate_mesh_data = child_mesh.data.copy()
                    duplicate_mesh = child_mesh.copy()
                    duplicate_mesh.data = duplicate_mesh_data
                    duplicate_mesh.parent = duplicate_armature
                    duplicate_mesh.modifiers["Armature"].object = duplicate_armature
                    context.scene.collection.objects.link(duplicate_mesh)

                    context_override = context.copy()
                    context_override["selected_objects"] = [duplicate_mesh]
                    with context.temp_override(**context_override):
                        bpy.ops.object.make_local(type="SELECT_OBDATA_MATERIAL")

                    # Use the name of the original mesh, and remove the conversion suffix.
                    file_name = child_mesh.name
                    if file_name.endswith(conversion_name_suffix):
                        file_name = file_name[:-len(conversion_name_suffix)]

                    directory_path = os.path.dirname(bpy.data.filepath)
                    export_path = f"{directory_path}\\{file_name}.fbx"

                    context_override = context.copy()
                    context_override["selected_objects"] = [duplicate_armature, duplicate_mesh]
                    with context.temp_override(**context_override):
                        bpy.ops.export_scene.fbx(
                            filepath=export_path,
                            use_selection=True,
                            use_visible=False,
                            object_types={"ARMATURE", "MESH"},
                            add_leaf_bones=False,
                            bake_anim=False,
                            mesh_smooth_type="FACE",
                            path_mode="RELATIVE"
                        )

                    # Remove the duplicate mesh.
                    remove_recursive(duplicate_mesh)

                # Remove the duplicate armature.
                remove_recursive(duplicate_armature)

        #
        # Remove converted armatures and their meshes.
        #

        for armature in conversion_dict:
            remove_recursive(armature)

        #
        # Restore selections.
        #

        bpy.ops.object.select_all(action="DESELECT")
        for o in old_selected_objects:
            o.select_set(True)
        context.view_layer.objects.active = old_active_object
        
        return {"FINISHED"}
    
    def invoke(self, context, event):
        valid_action_names = [x.name for x in bpy.data.actions if x.users > 0]

        # Remove invalid action properties.
        for action_property in (x for x in reversed(self.action_selections) if x.name not in valid_action_names):
            self.action_selections.remove(action_property)

        # Add missing action properties.
        for action_name in valid_action_names:
            if action_name not in (x.name for x in self.action_selections):
                new_action_property = self.action_selections.add()
                new_action_property.name = action_name

        return context.window_manager.invoke_props_dialog(self)

    def draw(self, context):
        layout = self.layout
        layout.label(text="Actions")
        layout.template_list(
            listtype_name="QUICK_ACTION_EXPORT_UL_action_selection",
            list_id="",
            dataptr=self,
            propname="action_selections",
            active_dataptr=self,
            active_propname="active_index",
            type="DEFAULT",
        )
        layout.prop(data=self, property="export_armature_and_meshes")

#
# Registration.
#

def menu_func(self, context):
    self.layout.operator(ExportToUEOperator.bl_idname, text=ExportToUEOperator.bl_label)

classes = (
    ActionSelectionProperty,
    ExportToUEOperator,
)

def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.TOPBAR_MT_file_export.append(menu_func)
    
def unregister():
    for c in classes:
        bpy.utils.unregister_class(c)
    bpy.types.TOPBAR_MT_file_export.remove(menu_func)
    