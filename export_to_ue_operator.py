import bpy
import os
import math
import mathutils


class ActionSelectionProperty(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty()
    include_in_export: bpy.props.BoolProperty(default=False)


#
# Operators.
#


class ExportToUEOperator(bpy.types.Operator):
    bl_idname = "export_to_ue.export"
    bl_label = "Export armature mesh to Unreal Engine"
    bl_description = "Exports selected armature objects and their meshes, and actions in scene, to FBX files that can be used in Unreal Engine"
    bl_options = {"REGISTER"}

    action_selections: bpy.props.CollectionProperty(type=ActionSelectionProperty)
    active_index: bpy.props.IntProperty()
    export_armature_meshes: bpy.props.BoolProperty(
        default=False,
        name="Export armature meshes",
        description="Export meshes that are children of selected armature.",
    )
    join_armature_meshes: bpy.props.BoolProperty(
        default=False,
        name="Join armature meshes",
        description="Join armatures meshes into one mesh.",
    )
    export_bone_child_meshes: bpy.props.BoolProperty(
        default=False,
        name="Export bone-parented meshes",
        description="Export meshes that are children of selected armature's bones.",
    )
    use_custom_name_prefix: bpy.props.BoolProperty(
        default=False,
        name="Use custom file name prefix",
        description="Use custom name prefix for exported files. By default armature name is used for actions and nothing for meshes. NOTE: This will break exporting multiple armatures at once.",
    )
    custom_name_prefix: bpy.props.StringProperty(
        name="Custom file name prefix",
        description="Use custom name prefix for exported files. By default armature name is used for actions and nothing for meshes. NOTE: This will break exporting multiple armatures at once.",
    )

    @classmethod
    def poll(cls, context):
        valid_armatures = [
            x
            for x in context.selected_objects
            if x.type == "ARMATURE"
            and any(child.type == "MESH" for child in x.children)
        ]
        return len(valid_armatures) > 0

    def execute(self, context):
        if not context.mode == "OBJECT":
            bpy.ops.object.mode_set(mode="OBJECT")

        old_selected_objects = [x for x in context.selected_objects]
        old_active_object = context.active_object

        #
        # Convert rigify armatures.
        #

        duplication_name_suffix = "_Temp"

        all_armatures = [
            x
            for x in context.selected_objects
            if x.type == "ARMATURE"
            and any(child.type == "MESH" for child in x.children)
        ]
        # rig_id is a custom property generated by rigify, use it to detect rigify rigs.
        rigify_armatures = [x for x in all_armatures if x.data.get("rig_id")]
        non_rigify_armatures = [x for x in all_armatures if not x.data.get("rig_id")]

        # Duplicate non-rigify rigs.
        duplicated_non_rigify_armatures = []
        for armature in non_rigify_armatures:
            # Don't duplicate actions.
            try:
                old_action = armature.animation_data.action
                armature.animation_data.action = None
            except AttributeError:
                old_action = None

            bpy.ops.object.select_all(action="DESELECT")

            duplicate_object_dict = {}
            for x in [armature] + armature.children_recursive:
                x.select_set(True)
                context.view_layer.objects.active = x

                bpy.ops.object.duplicate(linked=False)
                context.active_object.data = context.active_object.data.copy()
                context.active_object.name = (
                    f"{context.active_object.name[:-4]}{duplication_name_suffix}"
                )
                duplicate_object_dict[x] = context.active_object
                bpy.ops.object.select_all(action="DESELECT")

            for duplicate in duplicate_object_dict.values():
                try:
                    duplicate.parent = duplicate_object_dict[duplicate.parent]
                except KeyError:
                    pass

            duplicated_non_rigify_armatures.append(duplicate_object_dict[armature])

            try:
                armature.animation_data.action = old_action
            except AttributeError:
                pass

        # Duplicate rigify rigs.
        duplicated_rigify_armatures = []
        if len(rigify_armatures) > 0:
            bpy.ops.object.select_all(action="DESELECT")
            for armature in rigify_armatures:
                armature.select_set(True)
                context.view_layer.objects.active = armature
            bpy.ops.rigify_duplication.duplicate(name_suffix=duplication_name_suffix)
            duplicated_rigify_armatures = context.selected_objects

        duplicated_armatures = (
            duplicated_non_rigify_armatures + duplicated_rigify_armatures
        )
        objects_pending_removal = duplicated_armatures

        def remove_recursive(object):
            for child in object.children:
                remove_recursive(child)

            data = object.data
            bpy.data.objects.remove(object)
            try:
                bpy.data.meshes.remove(data)
            except TypeError:
                bpy.data.armatures.remove(data)

        def cleanup():
            for armature in objects_pending_removal:
                remove_recursive(armature)

            bpy.ops.object.select_all(action="DESELECT")
            for object in old_selected_objects:
                object.select_set(True)
            context.view_layer.objects.active = old_active_object

        def create_file_export_path(name):
            # Remove suffixes.
            file_name = name
            if len(file_name) > 4 and file_name[-4] == "." and file_name[-3:].isdigit():
                file_name = file_name[:-4]
            if file_name.endswith(duplication_name_suffix):
                file_name = file_name[: -len(duplication_name_suffix)]

            # Add custom prefix.
            if self.use_custom_name_prefix:
                file_name = f"{self.custom_name_prefix}_{file_name}"

            directory_path = os.path.dirname(bpy.data.filepath)
            return f"{directory_path}\\{file_name}.fbx"

        #
        # Export actions.
        #

        for armature in duplicated_armatures:
            bpy.ops.object.select_all(action="DESELECT")
            armature.select_set(True)
            context.view_layer.objects.active = armature

            if self.use_custom_name_prefix:
                base_name = self.custom_name_prefix
            else:
                if armature.name.endswith(duplication_name_suffix):
                    base_name = armature.name[: -len(duplication_name_suffix)]
                else:
                    base_name = armature.name

            action_selections = [
                {"name": x.name, "include_in_export": x.include_in_export}
                for x in self.action_selections
            ]

            if len(action_selections) > 0:
                bpy.ops.quick_action_exporter.export(
                    action_selections=action_selections,
                    active_index=0,
                    name_prefix=base_name,
                )

        # Reset transformations.
        for armature in all_armatures:
            for x in armature.pose.bones:
                x.matrix_basis = mathutils.Matrix.Identity(4)

        #
        # Export armature and meshes.
        #

        # Export armature meshes.
        if self.export_armature_meshes:
            for armature in duplicated_armatures:
                child_armature_meshes = [
                    child
                    for child in armature.children
                    if child.type == "MESH"
                    and any(
                        isinstance(modifier, bpy.types.ArmatureModifier)
                        and modifier.object == armature
                        for modifier in child.modifiers
                    )
                ]
                if len(child_armature_meshes) < 1:
                    continue

                if self.join_armature_meshes:
                    try:
                        main_rig = next(
                            x
                            for x in child_armature_meshes
                            if x.name.startswith(old_active_object.name)
                        )
                    except StopIteration:
                        main_rig = child_armature_meshes[0]

                    context_override = context.copy()
                    context_override["selected_objects"] = child_armature_meshes
                    context_override["selected_editable_objects"] = (
                        child_armature_meshes
                    )
                    context_override["active_object"] = main_rig
                    with context.temp_override(**context_override):
                        bpy.ops.object.join()
                    child_armature_meshes = [main_rig]

                # Rename armature to "Armature".
                if "Armature" in bpy.data.objects:
                    self.report({"ERROR"}, 'An object named "Armature" already exists.')
                    cleanup()
                    return {"CANCELLED"}
                if "Armature" in bpy.data.armatures:
                    self.report(
                        {"ERROR"}, 'Armature data named "Armature" already exists.'
                    )
                    cleanup()
                    return {"CANCELLED"}
                armature.name = "Armature"
                armature.data.name = "Armature"

                for child_mesh in child_armature_meshes:
                    context_override = context.copy()
                    context_override["selected_objects"] = [armature, child_mesh]
                    with context.temp_override(**context_override):
                        bpy.ops.export_scene.fbx(
                            filepath=create_file_export_path(child_mesh.name),
                            use_selection=True,
                            use_visible=False,
                            object_types={"ARMATURE", "MESH"},
                            add_leaf_bones=False,
                            bake_anim=False,
                            mesh_smooth_type="FACE",
                            path_mode="RELATIVE",
                        )

        # Export child meshes.
        if self.export_bone_child_meshes:
            bone_child_meshes = set([])
            for armature in duplicated_armatures:
                bone_child_meshes = bone_child_meshes.union(
                    {
                        child
                        for child in armature.children
                        if child.type == "MESH"
                        and child.parent_type == "BONE"
                        and child.parent_bone in armature.data.bones
                    }
                )

            for child_mesh in bone_child_meshes:
                parent_armature = child_mesh.parent
                parent_bone_name = child_mesh.parent_bone

                # Create a collision mesh.
                duplicate_collision_mesh = child_mesh.copy()
                duplicate_collision_mesh.data = child_mesh.data.copy()
                context.scene.collection.objects.link(duplicate_collision_mesh)
                duplicate_collision_mesh.name = f"UCX_{child_mesh.name}"

                # Clear parent.
                context_override = context.copy()
                context_override["selected_editable_objects"] = [
                    child_mesh,
                    duplicate_collision_mesh,
                ]
                with context.temp_override(**context_override):
                    bpy.ops.object.parent_clear(type="CLEAR")

                # Mark meshes for removal because they're no longer parented to armatures that are being removed.
                objects_pending_removal += [child_mesh, duplicate_collision_mesh]

                # Select armature.
                bpy.ops.object.select_all(action="DESELECT")
                parent_armature.select_set(True)
                context.view_layer.objects.active = parent_armature

                # Get bone transformation.
                bpy.ops.object.mode_set(mode="EDIT")
                parent_bone = parent_armature.data.edit_bones[parent_bone_name]
                inverse_matrix = parent_bone.matrix.inverted()
                bpy.ops.object.mode_set(mode="OBJECT")

                # Translate.
                context_override = context.copy()
                context_override["selected_objects"] = [
                    child_mesh,
                    duplicate_collision_mesh,
                ]
                context_override["selected_editable_objects"] = [
                    child_mesh,
                    duplicate_collision_mesh,
                ]
                with context.temp_override(**context_override):
                    bpy.ops.transform.translate(value=inverse_matrix.to_translation())

                # Rotate.
                child_mesh.rotation_quaternion = inverse_matrix.to_quaternion()
                child_mesh.rotation_euler = inverse_matrix.to_euler()
                duplicate_collision_mesh.rotation_quaternion = (
                    inverse_matrix.to_quaternion()
                )
                duplicate_collision_mesh.rotation_euler = inverse_matrix.to_euler()

                context_override = context.copy()
                context_override["selected_editable_objects"] = [
                    child_mesh,
                    duplicate_collision_mesh,
                ]
                with context.temp_override(**context_override):
                    bpy.ops.object.transform_apply(
                        location=True, rotation=True, scale=True
                    )

                context_override = context.copy()
                context_override["selected_objects"] = [
                    child_mesh,
                    duplicate_collision_mesh,
                ]
                with context.temp_override(**context_override):
                    bpy.ops.export_scene.fbx(
                        filepath=create_file_export_path(child_mesh.name),
                        use_selection=True,
                        use_visible=False,
                        object_types={"MESH"},
                        add_leaf_bones=False,
                        bake_anim=False,
                        mesh_smooth_type="FACE",
                        path_mode="RELATIVE",
                    )

                # remove_recursive(duplicate_collision_mesh)

        cleanup()
        return {"FINISHED"}

    def invoke(self, context, event):
        valid_action_names = [x.name for x in bpy.data.actions if x.users > 0]

        # Remove invalid action properties.
        for i in reversed(range(len(self.action_selections))):
            if self.action_selections[i].name not in valid_action_names:
                self.action_selections.remove(i)

        # Add missing action properties.
        for action_name in valid_action_names:
            if action_name not in (x.name for x in self.action_selections):
                new_action_property = self.action_selections.add()
                new_action_property.name = action_name

        return context.window_manager.invoke_props_dialog(self, width=400)

    def draw(self, context):
        layout = self.layout

        all_armatures = [
            x
            for x in context.selected_objects
            if x.type == "ARMATURE"
            and any(child.type == "MESH" for child in x.children)
        ]
        armature_count = len(all_armatures)
        armatures_string = (
            "Selected armatures " if armature_count > 1 else "Selected armature "
        )
        for i, x in enumerate(all_armatures):
            armatures_string += f', "{x.name}"' if i > 0 else f'"{x.name}"'
        layout.label(text=armatures_string)

        layout.label(text="Actions")
        layout.template_list(
            listtype_name="QUICK_ACTION_EXPORT_UL_action_selection",
            list_id="",
            dataptr=self,
            propname="action_selections",
            active_dataptr=self,
            active_propname="active_index",
            type="DEFAULT",
        )

        row = layout.row()
        row.prop(data=self, property="export_armature_meshes")
        row.prop(data=self, property="join_armature_meshes")

        layout.prop(data=self, property="export_bone_child_meshes")
        row = layout.row()
        row.prop(
            data=self, property="use_custom_name_prefix", text="Custom name prefix"
        )
        row2 = row.row()
        row2.prop(data=self, property="custom_name_prefix", text="")
        row2.enabled = self.use_custom_name_prefix


#
# Registration.
#


def menu_func(self, context):
    self.layout.operator(ExportToUEOperator.bl_idname, text=ExportToUEOperator.bl_label)


classes = (
    ActionSelectionProperty,
    ExportToUEOperator,
)


def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.TOPBAR_MT_file_export.append(menu_func)


def unregister():
    for c in classes:
        bpy.utils.unregister_class(c)
    bpy.types.TOPBAR_MT_file_export.remove(menu_func)
