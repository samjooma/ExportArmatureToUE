import bpy
import os
import math
import mathutils


class EXPORT_TO_UE_UL_export_selections(bpy.types.UIList):
    def draw_item(
        self, context, layout, data, item, icon, active_data, active_propname
    ):
        if self.layout_type in {"DEFAULT", "COMPACT", "GRID"}:
            row = layout.row(align=True)
            row.alignment = "LEFT"
            row.prop(data=item, property="include_in_export", icon_only=True)
            row.label(text=item.name, icon_value=icon)


class StringSelectionProperty(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty()
    include_in_export: bpy.props.BoolProperty(default=False)


class ArmatureMeshesProperty(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty()
    child_mesh_selections: bpy.props.CollectionProperty(type=StringSelectionProperty)
    active_index: bpy.props.IntProperty()


#
# Operators.
#


class ExportToUEOperator(bpy.types.Operator):
    bl_idname = "export_to_ue.export"
    bl_label = "Export armature mesh to Unreal Engine"
    bl_description = "Exports selected armature objects and their meshes, and actions in scene, to FBX files that can be used in Unreal Engine"
    bl_options = {"REGISTER"}

    action_selections: bpy.props.CollectionProperty(type=StringSelectionProperty)
    active_index: bpy.props.IntProperty()
    armature_mesh_names: bpy.props.CollectionProperty(type=ArmatureMeshesProperty)
    join_armature_meshes: bpy.props.BoolProperty(
        default=False,
        name="Join armature meshes",
        description="Join armatures meshes into one mesh.",
    )
    export_bone_child_meshes: bpy.props.BoolProperty(
        default=False,
        name="Export bone-parented meshes",
        description="Export meshes that are children of selected armature's bones.",
    )
    use_custom_name_prefix: bpy.props.BoolProperty(
        default=False,
        name="Use custom file name prefix",
        description="Use custom name prefix for exported files. By default armature name is used for actions and nothing for meshes. NOTE: This will break exporting multiple armatures at once.",
    )
    custom_name_prefix: bpy.props.StringProperty(
        name="Custom file name prefix",
        description="Use custom name prefix for exported files. By default armature name is used for actions and nothing for meshes. NOTE: This will break exporting multiple armatures at once.",
    )

    @classmethod
    def poll(cls, context):
        valid_armatures = [
            x
            for x in context.selected_objects
            if x.type == "ARMATURE"
            and any(child.type == "MESH" for child in x.children)
        ]
        return len(valid_armatures) > 0

    def execute(self, context):
        if not context.mode == "OBJECT":
            bpy.ops.object.mode_set(mode="OBJECT")

        old_selected_objects = [x for x in context.selected_objects]
        old_active_object = context.active_object

        #
        # Convert rigify armatures.
        #

        duplication_name_suffix = "_Temp"

        original_armatures = [
            bpy.data.objects[x.name] for x in self.armature_mesh_names
        ]
        mesh_names_to_export = []
        for armature_property in self.armature_mesh_names:
            mesh_names_to_export = mesh_names_to_export + [
                x.name
                for x in armature_property.child_mesh_selections
                if x.include_in_export
            ]

        # rig_id is a custom property generated by rigify, use it to detect rigify rigs.
        original_rigify_armatures = [
            x for x in original_armatures if x.data.get("rig_id")
        ]
        original_non_rigify_armatures = [
            x for x in original_armatures if not x.data.get("rig_id")
        ]

        # Duplicate non-rigify rigs.
        duplicated_non_rigify_armatures = []
        for armature in original_non_rigify_armatures:
            # Don't duplicate actions.
            try:
                old_action = armature.animation_data.action
                armature.animation_data.action = None
            except AttributeError:
                old_action = None

            bpy.ops.object.select_all(action="DESELECT")

            duplicate_object_dict = {}
            for x in [armature] + armature.children_recursive:
                x.select_set(True)
                context.view_layer.objects.active = x

                bpy.ops.object.duplicate(linked=False)
                context.active_object.data = context.active_object.data.copy()
                context.active_object.name = f"{x.name}{duplication_name_suffix}"
                duplicate_object_dict[x] = context.active_object
                bpy.ops.object.select_all(action="DESELECT")

            for duplicate in duplicate_object_dict.values():
                try:
                    duplicate.parent = duplicate_object_dict[duplicate.parent]
                except KeyError:
                    pass

            for duplicate in duplicate_object_dict.values():
                for modifier in (
                    x
                    for x in duplicate.modifiers
                    if isinstance(x, bpy.types.ArmatureModifier)
                ):
                    try:
                        modifier.object = duplicate_object_dict[modifier.object]
                    except KeyError:
                        pass

            duplicated_non_rigify_armatures.append(duplicate_object_dict[armature])

            try:
                armature.animation_data.action = old_action
            except AttributeError:
                pass

        # Duplicate rigify rigs.
        duplicated_rigify_armatures = []
        if len(original_rigify_armatures) > 0:
            bpy.ops.object.select_all(action="DESELECT")
            for armature in original_rigify_armatures:
                armature.select_set(True)
                context.view_layer.objects.active = armature
            bpy.ops.rigify_duplication.duplicate(name_suffix=duplication_name_suffix)
            duplicated_rigify_armatures = context.selected_objects

        duplicated_armatures = (
            duplicated_non_rigify_armatures + duplicated_rigify_armatures
        )
        objects_pending_removal = duplicated_armatures

        def remove_recursive(object):
            for child in object.children:
                remove_recursive(child)

            data = object.data
            bpy.data.objects.remove(object)
            try:
                bpy.data.meshes.remove(data)
            except TypeError:
                bpy.data.armatures.remove(data)

        def cleanup():
            for armature in objects_pending_removal:
                remove_recursive(armature)

            bpy.ops.object.select_all(action="DESELECT")
            for object in old_selected_objects:
                object.select_set(True)
            context.view_layer.objects.active = old_active_object

        def create_file_export_path(name):
            # Remove suffixes.
            file_name = name
            if len(file_name) > 4 and file_name[-4] == "." and file_name[-3:].isdigit():
                file_name = file_name[:-4]
            if file_name.endswith(duplication_name_suffix):
                file_name = file_name[: -len(duplication_name_suffix)]

            # Add custom prefix.
            if self.use_custom_name_prefix:
                file_name = f"{self.custom_name_prefix}_{file_name}"

            directory_path = os.path.dirname(bpy.data.filepath)
            return f"{directory_path}\\{file_name}.fbx"

        #
        # Export actions.
        #

        for armature in duplicated_armatures:
            bpy.ops.object.select_all(action="DESELECT")
            armature.select_set(True)
            context.view_layer.objects.active = armature

            if self.use_custom_name_prefix:
                base_name = self.custom_name_prefix
            else:
                if armature.name.endswith(duplication_name_suffix):
                    base_name = armature.name[: -len(duplication_name_suffix)]
                else:
                    base_name = armature.name

            action_selections = [
                {"name": x.name, "include_in_export": x.include_in_export}
                for x in self.action_selections
            ]

            if len(action_selections) > 0:
                bpy.ops.quick_action_exporter.export(
                    action_selections=action_selections,
                    active_index=0,
                    name_prefix=base_name,
                )

        # Reset transformations.
        for armature in original_armatures:
            for x in armature.pose.bones:
                x.matrix_basis = mathutils.Matrix.Identity(4)

        #
        # Export armature and meshes.
        #

        # Export armature meshes.
        for armature in duplicated_armatures:
            valid_child_meshes = [
                child
                for child in armature.children
                if child.type == "MESH"
                and child.name[: -len(duplication_name_suffix)] in mesh_names_to_export
                and any(
                    isinstance(modifier, bpy.types.ArmatureModifier)
                    and modifier.object == armature
                    for modifier in child.modifiers
                )
            ]
            if len(valid_child_meshes) < 1:
                continue

            if self.join_armature_meshes:
                try:
                    main_rig = next(
                        x
                        for x in valid_child_meshes
                        if x.name.startswith(old_active_object.name)
                    )
                except StopIteration:
                    main_rig = valid_child_meshes[0]

                context_override = context.copy()
                context_override["selected_objects"] = valid_child_meshes
                context_override["selected_editable_objects"] = valid_child_meshes
                context_override["active_object"] = main_rig
                with context.temp_override(**context_override):
                    bpy.ops.object.join()
                valid_child_meshes = [main_rig]

            # Rename armature to "Armature".
            if "Armature" in bpy.data.objects:
                self.report({"ERROR"}, 'An object named "Armature" already exists.')
                cleanup()
                return {"CANCELLED"}
            if "Armature" in bpy.data.armatures:
                self.report({"ERROR"}, 'Armature data named "Armature" already exists.')
                cleanup()
                return {"CANCELLED"}

            old_name = armature.name
            old_data_name = armature.data.name
            armature.name = "Armature"
            armature.data.name = "Armature"

            for child_mesh in valid_child_meshes:
                context_override = context.copy()
                context_override["selected_objects"] = [armature, child_mesh]
                with context.temp_override(**context_override):
                    bpy.ops.export_scene.fbx(
                        filepath=create_file_export_path(child_mesh.name),
                        use_selection=True,
                        use_visible=False,
                        object_types={"ARMATURE", "MESH"},
                        add_leaf_bones=False,
                        bake_anim=False,
                        mesh_smooth_type="FACE",
                        path_mode="RELATIVE",
                    )

            armature.name = old_name
            armature.data.name = old_data_name

        # Export child meshes.
        if self.export_bone_child_meshes:
            bone_child_meshes = set([])
            for armature in duplicated_armatures:
                bone_child_meshes = bone_child_meshes.union(
                    {
                        child
                        for child in armature.children
                        if child.type == "MESH"
                        and child.parent_type == "BONE"
                        and child.parent_bone in armature.data.bones
                    }
                )

            for child_mesh in bone_child_meshes:
                parent_armature = child_mesh.parent
                parent_bone_name = child_mesh.parent_bone

                # Create a collision mesh.
                duplicate_collision_mesh = child_mesh.copy()
                duplicate_collision_mesh.data = child_mesh.data.copy()
                context.scene.collection.objects.link(duplicate_collision_mesh)
                duplicate_collision_mesh.name = f"UCX_{child_mesh.name}"

                # Clear parent.
                context_override = context.copy()
                context_override["selected_editable_objects"] = [
                    child_mesh,
                    duplicate_collision_mesh,
                ]
                with context.temp_override(**context_override):
                    bpy.ops.object.parent_clear(type="CLEAR")

                # Mark meshes for removal because they're no longer parented to armatures that are being removed.
                objects_pending_removal += [child_mesh, duplicate_collision_mesh]

                # Select armature.
                bpy.ops.object.select_all(action="DESELECT")
                parent_armature.select_set(True)
                context.view_layer.objects.active = parent_armature

                # Get bone transformation.
                bpy.ops.object.mode_set(mode="EDIT")
                parent_bone = parent_armature.data.edit_bones[parent_bone_name]
                inverse_matrix = parent_bone.matrix.inverted()
                bpy.ops.object.mode_set(mode="OBJECT")

                # Translate.
                context_override = context.copy()
                context_override["selected_objects"] = [
                    child_mesh,
                    duplicate_collision_mesh,
                ]
                context_override["selected_editable_objects"] = [
                    child_mesh,
                    duplicate_collision_mesh,
                ]
                with context.temp_override(**context_override):
                    bpy.ops.transform.translate(value=inverse_matrix.to_translation())

                # Rotate.
                child_mesh.rotation_quaternion = inverse_matrix.to_quaternion()
                child_mesh.rotation_euler = inverse_matrix.to_euler()
                duplicate_collision_mesh.rotation_quaternion = (
                    inverse_matrix.to_quaternion()
                )
                duplicate_collision_mesh.rotation_euler = inverse_matrix.to_euler()

                context_override = context.copy()
                context_override["selected_editable_objects"] = [
                    child_mesh,
                    duplicate_collision_mesh,
                ]
                with context.temp_override(**context_override):
                    bpy.ops.object.transform_apply(
                        location=True, rotation=True, scale=True
                    )

                context_override = context.copy()
                context_override["selected_objects"] = [
                    child_mesh,
                    duplicate_collision_mesh,
                ]
                with context.temp_override(**context_override):
                    bpy.ops.export_scene.fbx(
                        filepath=create_file_export_path(child_mesh.name),
                        use_selection=True,
                        use_visible=False,
                        object_types={"MESH"},
                        add_leaf_bones=False,
                        bake_anim=False,
                        mesh_smooth_type="FACE",
                        path_mode="RELATIVE",
                    )

        cleanup()
        return {"FINISHED"}

    def invoke(self, context, event):
        def refresh_collection_by_name(property_collection, valid_property_names):
            # Remove invalid action properties.
            for i in reversed(range(len(property_collection))):
                if property_collection[i].name not in valid_property_names:
                    property_collection.remove(i)

            # Add missing action properties.
            for name in valid_property_names:
                if name not in (x.name for x in property_collection):
                    new_action_property = property_collection.add()
                    new_action_property.name = name

        valid_action_names = [x.name for x in bpy.data.actions if x.users > 0]
        valid_armature_names = [
            x.name for x in context.selected_objects if x.type == "ARMATURE"
        ]

        refresh_collection_by_name(self.action_selections, valid_action_names)
        refresh_collection_by_name(self.armature_mesh_names, valid_armature_names)

        for armature_mesh_property in self.armature_mesh_names:
            armature = bpy.data.objects[armature_mesh_property.name]

            valid_child_mesh_names = [
                child.name
                for child in armature.children
                if child.type == "MESH"
                and any(
                    isinstance(modifier, bpy.types.ArmatureModifier)
                    and modifier.object == armature
                    for modifier in child.modifiers
                )
            ]
            refresh_collection_by_name(
                armature_mesh_property.child_mesh_selections, valid_child_mesh_names
            )

        return context.window_manager.invoke_props_dialog(self, width=400)

    def draw(self, context):
        layout = self.layout

        for armature_property in self.armature_mesh_names:
            label_text = f'Armature: "{armature_property.name}", meshes:'
            layout.label(text=label_text)
            layout.template_list(
                listtype_name="EXPORT_TO_UE_UL_export_selections",
                list_id="",
                dataptr=armature_property,
                propname="child_mesh_selections",
                active_dataptr=armature_property,
                active_propname="active_index",
                type="DEFAULT",
            )

        layout.label(text="Actions")
        layout.template_list(
            listtype_name="EXPORT_TO_UE_UL_export_selections",
            list_id="",
            dataptr=self,
            propname="action_selections",
            active_dataptr=self,
            active_propname="active_index",
            type="DEFAULT",
        )

        row = layout.row()
        row.prop(data=self, property="join_armature_meshes")

        layout.prop(data=self, property="export_bone_child_meshes")
        row = layout.row()
        row.prop(
            data=self, property="use_custom_name_prefix", text="Custom name prefix"
        )
        row2 = row.row()
        row2.prop(data=self, property="custom_name_prefix", text="")
        row2.enabled = self.use_custom_name_prefix


#
# Registration.
#


def menu_func(self, context):
    self.layout.operator(ExportToUEOperator.bl_idname, text=ExportToUEOperator.bl_label)


classes = (
    EXPORT_TO_UE_UL_export_selections,
    StringSelectionProperty,
    ArmatureMeshesProperty,
    ExportToUEOperator,
)


def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.TOPBAR_MT_file_export.append(menu_func)


def unregister():
    for c in classes:
        bpy.utils.unregister_class(c)
    bpy.types.TOPBAR_MT_file_export.remove(menu_func)
