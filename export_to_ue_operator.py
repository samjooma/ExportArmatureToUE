import bpy
import os
import math

class ActionSelectionProperty(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty()
    include_in_export: bpy.props.BoolProperty(default=False)

#
# Operators.
#

class ExportToUEOperator(bpy.types.Operator):
    bl_idname = "export_to_ue.export"
    bl_label = "Export to Unreal Engine"
    bl_description = "Exports selected armature objects and their meshes, and actions in scene, to FBX files that can be used in Unreal Engine"
    bl_options = {"REGISTER"}

    action_selections: bpy.props.CollectionProperty(type=ActionSelectionProperty)
    active_index: bpy.props.IntProperty()
    export_armature_meshes: bpy.props.BoolProperty(default=False, name="Export armature meshes")
    export_child_meshes: bpy.props.BoolProperty(default=False, name="Export bone-parented meshes")

    @classmethod
    def poll(cls, context):
        valid_armatures = [
            x for x in context.selected_objects if
            x.type == "ARMATURE" and any(child.type == "MESH" for child in x.children)
        ]
        return len(valid_armatures) > 0

    def execute(self, context):
        if not context.mode == "OBJECT":
            bpy.ops.object.mode_set(mode="OBJECT")

        old_selected_objects = [x for x in context.selected_objects]
        old_active_object = context.active_object

        #
        # Convert rigify armatures.
        #

        conversion_name_suffix = "_Converted"

        all_armatures = [x for x in context.selected_objects if x.type == "ARMATURE" and any(child.type == "MESH" for child in x.children)]
        # rig_id is a custom property generated by rigify, use it to detect rigify rigs.
        rigify_armatures = [x for x in all_armatures if x.data.get("rig_id")]
        non_rigify_armatures = [x for x in all_armatures if not x.data.get("rig_id")]

        created_armatures = []
        if len(rigify_armatures) > 0:
            bpy.ops.object.select_all(action="DESELECT")
            for armature in rigify_armatures:
                armature.select_set(True)
                context.view_layer.objects.active = armature
            bpy.ops.rigify_duplication.duplicate(name_suffix=conversion_name_suffix)
            created_armatures = context.selected_objects

        armatures_to_export = non_rigify_armatures + created_armatures

        #
        # Export actions.
        #

        for armature in armatures_to_export:
            bpy.ops.object.select_all(action="DESELECT")
            armature.select_set(True)
            context.view_layer.objects.active = armature
            
            if armature.name.endswith(conversion_name_suffix):
                base_name = armature.name[:-len(conversion_name_suffix)]
            else:
                base_name = armature.name

            action_selections = [{"name": x.name, "include_in_export": x.include_in_export} for x in self.action_selections]
            if len(action_selections) > 1:
                bpy.ops.quick_action_exporter.export(action_selections=action_selections, active_index=0, name_prefix=base_name)

        #
        # Export armature and meshes.
        #

        def remove_recursive(object):
            for child in object.children:
                remove_recursive(child)
            
            data = object.data
            bpy.data.objects.remove(object)
            try:
                bpy.data.meshes.remove(data)
            except TypeError:
                bpy.data.armatures.remove(data)

        # Export armature meshes.
        if self.export_armature_meshes:
            for armature in armatures_to_export:
                child_armature_meshes = [
                    x for x in armature.children if
                    x.type == "MESH" and
                    any(isinstance(y, bpy.types.ArmatureModifier) and y.object == armature for y in x.modifiers)
                ]
                if len(child_armature_meshes) < 1:
                    continue

                # Rename armature to "Armature".
                if "Armature" in bpy.data.objects:
                    self.report({"ERROR"}, "An object named \"Armature\" already exists.")
                    return {"Canceled"}
                if "Armature" in bpy.data.armatures:
                    self.report({"ERROR"}, "Armature data named \"Armature\" already exists.")
                    return {"Canceled"}
                armature.name = "Armature"
                armature.data.name = "Armature"

                for child_mesh in child_armature_meshes:
                    # Use mesh name as the file name, but remove suffixes.
                    file_name = child_mesh.name
                    if len(file_name) > 4 and file_name[-4] == "." and file_name[-3:].isdigit():
                        file_name = file_name[:-4]
                    if file_name.endswith(conversion_name_suffix):
                        file_name = file_name[:-len(conversion_name_suffix)]

                    directory_path = os.path.dirname(bpy.data.filepath)
                    export_path = f"{directory_path}\\{file_name}.fbx"

                    context_override = context.copy()
                    context_override["selected_objects"] = [armature, child_mesh]
                    with context.temp_override(**context_override):
                        bpy.ops.export_scene.fbx(
                            filepath=export_path,
                            use_selection=True,
                            use_visible=False,
                            object_types={"ARMATURE", "MESH"},
                            add_leaf_bones=False,
                            bake_anim=False,
                            mesh_smooth_type="FACE",
                            path_mode="RELATIVE"
                        )
        
        # Export non-armature child meshes.
        if self.export_child_meshes:
            non_armature_child_meshes = set([])
            for armature in armatures_to_export:
                non_armature_child_meshes = non_armature_child_meshes.union({
                    x for x in armature.children if
                    x.type == "MESH" and x.parent_type == "BONE" and x.parent_bone in armature.data.bones
                })

            for child_mesh in non_armature_child_meshes:
                duplicate_mesh = child_mesh.copy()
                duplicate_mesh.data = child_mesh.data.copy()

                duplicate_collision_mesh = child_mesh.copy()
                duplicate_collision_mesh.data = child_mesh.data.copy()

                context.scene.collection.objects.link(duplicate_mesh)
                context.scene.collection.objects.link(duplicate_collision_mesh)
                parent_bone_name = duplicate_mesh.parent_bone
                duplicate_collision_mesh.name = f"UCX_{duplicate_mesh.name}"

                # Clear parent.
                context_override = context.copy()
                context_override["selected_editable_objects"] = [duplicate_mesh, duplicate_collision_mesh]
                with context.temp_override(**context_override):
                    bpy.ops.object.parent_clear(type="CLEAR")

                # Select armature.
                armature = child_mesh.parent
                bpy.ops.object.select_all(action="DESELECT")
                armature.select_set(True)
                context.view_layer.objects.active = armature

                # Get bone transformation.
                bpy.ops.object.mode_set(mode="EDIT")
                parent_bone = armature.data.edit_bones[parent_bone_name]
                inverse_matrix = parent_bone.matrix.inverted()
                bpy.ops.object.mode_set(mode="OBJECT")
                
                # Translate.
                context_override = context.copy()
                context_override["selected_objects"] = [duplicate_mesh, duplicate_collision_mesh]
                context_override["selected_editable_objects"] = [duplicate_mesh, duplicate_collision_mesh]
                with context.temp_override(**context_override):
                    bpy.ops.transform.translate(value=inverse_matrix.to_translation())

                # Rotate.
                duplicate_mesh.rotation_quaternion = inverse_matrix.to_quaternion()
                duplicate_mesh.rotation_euler = inverse_matrix.to_euler()
                duplicate_collision_mesh.rotation_quaternion = inverse_matrix.to_quaternion()
                duplicate_collision_mesh.rotation_euler = inverse_matrix.to_euler()

                context_override = context.copy()
                context_override["selected_editable_objects"] = [duplicate_mesh, duplicate_collision_mesh]
                with context.temp_override(**context_override):
                    bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)

                # Use mesh name as the file name, but remove suffixes.
                file_name = child_mesh.name
                if len(file_name) > 4 and file_name[-4] == "." and file_name[-3:].isdigit():
                    file_name = file_name[:-4]
                if file_name.endswith(conversion_name_suffix):
                    file_name = file_name[:-len(conversion_name_suffix)]

                directory_path = os.path.dirname(bpy.data.filepath)
                export_path = f"{directory_path}\\{file_name}.fbx"

                context_override = context.copy()
                context_override["selected_objects"] = [duplicate_mesh, duplicate_collision_mesh]
                with context.temp_override(**context_override):
                    bpy.ops.export_scene.fbx(
                        filepath=export_path,
                        use_selection=True,
                        use_visible=False,
                        object_types={"MESH"},
                        add_leaf_bones=False,
                        bake_anim=False,
                        mesh_smooth_type="FACE",
                        path_mode="RELATIVE"
                    )

                remove_recursive(duplicate_mesh)
                remove_recursive(duplicate_collision_mesh)

        # Remove converted armatures and their meshes.
        for armature in created_armatures:
            remove_recursive(armature)

        #
        # Restore selections.
        #

        bpy.ops.object.select_all(action="DESELECT")
        for object in old_selected_objects:
            object.select_set(True)
        context.view_layer.objects.active = old_active_object
    
        return {"FINISHED"}
    
    def invoke(self, context, event):
        valid_action_names = [x.name for x in bpy.data.actions if x.users > 0]

        # Remove invalid action properties.
        for i in reversed(range(len(self.action_selections))):
            if self.action_selections[i].name not in valid_action_names:
                self.action_selections.remove(i)
        
        # Add missing action properties.
        for action_name in valid_action_names:
            if action_name not in (x.name for x in self.action_selections):
                new_action_property = self.action_selections.add()
                new_action_property.name = action_name

        return context.window_manager.invoke_props_dialog(self)

    def draw(self, context):
        layout = self.layout
        layout.label(text="Actions")
        layout.template_list(
            listtype_name="QUICK_ACTION_EXPORT_UL_action_selection",
            list_id="",
            dataptr=self,
            propname="action_selections",
            active_dataptr=self,
            active_propname="active_index",
            type="DEFAULT",
        )
        layout.prop(data=self, property="export_armature_meshes")
        layout.prop(data=self, property="export_child_meshes")

#
# Registration.
#

def menu_func(self, context):
    self.layout.operator(ExportToUEOperator.bl_idname, text=ExportToUEOperator.bl_label)

classes = (
    ActionSelectionProperty,
    ExportToUEOperator,
)

def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.TOPBAR_MT_file_export.append(menu_func)
    
def unregister():
    for c in classes:
        bpy.utils.unregister_class(c)
    bpy.types.TOPBAR_MT_file_export.remove(menu_func)
    